import os
import logging
from datetime import datetime
import pytz
from dotenv import load_dotenv
from flask import Flask, jsonify, request
from flask_socketio import SocketIO, emit
from flask_cors import CORS
import alpaca_service
import trade_executor
import openai

# Load environment variables first
load_dotenv()
env_path = os.path.join(os.path.dirname(__file__), '.env')
logger = logging.getLogger(__name__)
logging.basicConfig(
    filename='logs/app.log',
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger.info(f"Loading .env from: {env_path}")
logger.info(f"APCA_API_KEY_ID: {os.getenv('APCA_API_KEY_ID')}")
logger.info(f"APCA_API_SECRET_KEY: {os.getenv('APCA_API_SECRET_KEY')}")
logger.info(f"OPENAI_API_KEY: {os.getenv('OPENAI_API_KEY')}")

# Check for required environment variables
if not os.getenv("APCA_API_KEY_ID") or not os.getenv("APCA_API_SECRET_KEY"):
    logger.error("Missing Alpaca API credentials in environment")
    raise ValueError("APCA_API_KEY_ID and APCA_API_SECRET_KEY must be set in .env or environment variables")
openai.api_key = os.getenv("OPENAI_API_KEY")
if not openai.api_key:
    logger.error("Missing OpenAI API key in environment")
    raise ValueError("OPENAI_API_KEY must be set in .env or environment variables")

# Initialize Flask and SocketIO
app = Flask(__name__)
CORS(app, resources={r"/api/*": {"origins": "http://localhost:3000"}, r"/socket.io/*": {"origins": "http://localhost:3000"}})
socketio = SocketIO(app, cors_allowed_origins="http://localhost:3000", async_mode='eventlet', logger=True, engineio_logger=True)

# Database configuration
DATABASE_URI = "sqlite:///trades.db"
logger.info(f"Using DATABASE_URI: {DATABASE_URI}")

def setup_database():
    from database import get_db_connection
    conn = get_db_connection()
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS trades (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT NOT NULL,
            action TEXT NOT NULL,
            quantity REAL NOT NULL,
            price REAL,
            status TEXT NOT NULL,
            timestamp TEXT NOT NULL,
            confidence REAL DEFAULT 0.75,
            source TEXT,
            user TEXT,
            url TEXT,
            option_details TEXT,
            closed INTEGER DEFAULT 0,
            closed_timestamp TEXT
        )
    """)

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS market_insights (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            symbol TEXT NOT NULL,
            title TEXT,
            summary TEXT,
            takeaways TEXT,
            timestamp TEXT NOT NULL
        )
    """)

    cursor.execute("PRAGMA table_info(trades)")
    columns = {row[1] for row in cursor.fetchall()}
    if 'closed' not in columns:
        try:
            cursor.execute("ALTER TABLE trades ADD COLUMN closed INTEGER DEFAULT 0")
        except Exception as e:
            logger.warning(f"Could not add 'closed' column: {str(e)}")
    if 'closed_timestamp' not in columns:
        try:
            cursor.execute("ALTER TABLE trades ADD COLUMN closed_timestamp TEXT")
        except Exception as e:
            logger.warning(f"Could not add 'closed_timestamp' column: {str(e)}")

    conn.commit()
    conn.close()
    logger.info("Database setup completed successfully")

try:
    setup_database()
except Exception as e:
    logger.error(f"Error setting up database: {str(e)}")
    raise

# Add a test endpoint to verify the server
@app.route('/api/test', methods=['GET'])
def test_server():
    logger.info("Test endpoint accessed")
    return jsonify({"message": "Server is running"}), 200

# Add a route to trigger a manual trade update
@app.route('/api/trigger-trade', methods=['POST'])
def trigger_trade():
    sample_trade = {
        "symbol": "AAPL",
        "action": "buy",
        "contracts": 1,
        "option_details": "CALL",
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "source": "TestSource",
        "user": "TestUser",
        "url": "http://example.com",
        "status": "pending",
        "confidence": 0.85
    }
    socketio.emit('live_trade_update', sample_trade)
    logger.info(f"Manually triggered trade update: {sample_trade}")
    return jsonify({"message": "Trade update triggered", "trade": sample_trade}), 200

@app.route("/api/trades", methods=["POST"])
def process_trade():
    data = request.get_json()
    if not data or "symbol" not in data:
        return jsonify({"error": "Missing symbol in request"}), 400

    symbol = data.get("symbol").upper()
    source = data.get("source", "unknown")
    user = data.get("user", "unknown")
    url = data.get("url")

    action = "buy" if "BOUGHT" in symbol else "sell" if "SOLD" in symbol or "ALL OUT" in symbol else None
    if not action:
        return jsonify({"error": "Invalid action in symbol"}), 400

    parts = symbol.split()
    if len(parts) < 2:
        return jsonify({"error": "Invalid symbol format"}), 400

    symbol = parts[1]
    option_details = None
    price = None
    for part in parts[2:]:
        if "C" in part or "P" in part:
            option_details = part
        try:
            price = float(part)
        except ValueError:
            continue

    parsed_alert = {
        "symbol": symbol,
        "action": action,
        "contracts": 1,
        "option_details": option_details,
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "source": source,
        "user": user,
        "url": url,
        "status": "pending",
        "confidence": 0.65
    }

    try:
        eastern = pytz.timezone('US/Eastern')
        now = datetime.now(pytz.UTC).astimezone(eastern)
        market_data = {
            "SPX": alpaca_service.get_stock_data("SPX", now),
            "VIX": alpaca_service.get_stock_data("VIX", now)
        }
        prompt = (
            f"Generate a market insight for {symbol} based on the following market data:\n"
            f"SPX: {market_data['SPX']}\n"
            f"VIX: {market_data['VIX']}\n"
            f"Provide a concise summary (1-2 sentences) and 2-3 key takeaways as bullet points."
        )
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are a financial analyst providing market insights."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=150
        )
        insight_text = response.choices[0].message['content']
        summary = insight_text.split('\n')[0]
        takeaways = [line.strip('- ') for line in insight_text.split('\n')[1:] if line.startswith('-')]

        from database import get_db_connection
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO market_insights (symbol, title, summary, takeaways, timestamp) VALUES (?, ?, ?, ?, ?)",
            (symbol, f"{symbol} Market Insights", summary, "; ".join(takeaways), parsed_alert["timestamp"])
        )
        conn.commit()
        conn.close()
        socketio.emit('market_insight_update', {"symbol": symbol, "title": f"{symbol} Market Insights", "summary": summary, "takeaways": takeaways, "timestamp": parsed_alert["timestamp"]})
        logger.info(f"Generated market insight for {symbol}")
    except Exception as e:
        logger.error(f"Error generating market insight for {symbol}: {str(e)}")

    result = trade_executor.execute_trade(parsed_alert, entry_price=price)
    parsed_alert["status"] = result.get("status", "rejected")

    from database import get_db_connection
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO trades (symbol, action, quantity, price, status, timestamp, confidence, source, user, url, option_details) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
        (parsed_alert["symbol"], parsed_alert["action"], parsed_alert["contracts"], price, parsed_alert["status"], parsed_alert["timestamp"], parsed_alert["confidence"], parsed_alert["source"], parsed_alert["user"], parsed_alert["url"], parsed_alert["option_details"])
    )
    conn.commit()
    conn.close()

    socketio.emit('live_trade_update', parsed_alert)
    logger.info(f"Automatically executed trade: {parsed_alert}")
    return jsonify(parsed_alert)

@app.route("/api/dashboard-data", methods=["GET"])
def get_dashboard_data():
    try:
        from database import get_db_connection
        conn = get_db_connection()
        cursor = conn.cursor()

        cursor.execute("SELECT id, symbol, action, quantity, price, status, timestamp, confidence, source, user, url, option_details, closed, closed_timestamp FROM trades ORDER BY timestamp DESC LIMIT 10")
        trades = [
            {
                "id": row[0],
                "symbol": row[1],
                "action": row[2],
                "quantity": row[3],
                "price": row[4],
                "status": row[5],
                "timestamp": row[6],
                "confidence": row[7],
                "source": row[8],
                "user": row[9],
                "url": row[10],
                "option_details": row[11],
                "closed": bool(row[12]),
                "closed_timestamp": row[13],
                "current_price": row[4] * 1.15 if row[2] == 'buy' and not row[12] else row[4] * 0.85 if row[2] == 'buy' else row[4],  # Mock dynamic price
                "target": row[4] * 2,
                "stop": row[4] * 0.5
            } for row in cursor.fetchall()
        ]

        cursor.execute("SELECT symbol, title, summary, takeaways, timestamp FROM market_insights ORDER BY timestamp DESC LIMIT 5")
        insights = [
            {
                "symbol": row[0],
                "title": row[1],
                "summary": row[2],
                "takeaways": row[3].split("; ") if row[3] else [],
                "timestamp": row[4]
            } for row in cursor.fetchall()
        ]

        conn.close()
        return jsonify({"trades": trades, "insights": insights})
    except Exception as e:
        logger.error(f"Error fetching dashboard data: {str(e)}")
        return jsonify({"error": str(e)}), 500

@socketio.on('connect')
def handle_connect():
    logger.info("Client connected successfully")
    emit('connection_response', {'status': 'connected'})

@socketio.on('disconnect')
def handle_disconnect():
    logger.info("Client disconnected successfully")

@socketio.on('error')
def handle_error(error):
    logger.error(f"SocketIO error: {str(error)}")

if __name__ == "__main__":
    port = int(os.getenv("PORT", 5000))
    logger.info(f"Starting server on port {port}")
    socketio.run(app, host="0.0.0.0", port=port)